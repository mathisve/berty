# Infra testing tool

## Prerequisites

### Dependencies
In order to use the infra-testing-tool you need a handful of other tools installed.
- [AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html) (to the tool supply tool with credentials) If already installed,
  Make sure it is set to the `eu-central-1` (**frankfurt**) region.
- [Terraform](https://www.terraform.io/downloads.html) (to provision infrastructure)
- [Packer](https://learn.hashicorp.com/tutorials/packer/get-started-install-cli) (to create the berty AMI)

### Install
```bash
make build && sudo mv infra /usr/local/bin
```

### AMI (Amazon Machine Image)
To speed up the tool considerably we build an AMI beforehand, so our cloud instances don't need to build the Berty CLI from source every time they get launched.
If this is your first time using the tool, or you want to rebuild the AMI you need to follow the next steps:
```bash
cd packer
packer build --force berty.pkr.hcl # this will delete any AMIs with the name "berty-ami" in that region!
```
After you've executed these commands, it will start building the machine images. This could take roughly 15 minutes.
When Packer has completed you can continue to the next step.

## Usage
### Generate config
This command generates the underlying *infrastructure as code* as well as a state file.
You can find these in the folder `infraState`, but they shouldn't be manually changed.
The flag `-f` points to your yaml configuration file.
```bash
infra generate -f conf.yaml
```

### Deploy infrastructure
This command will take the `infraState/main.tf` file and deploy it to AWS as described.
```bash
infra deploy
```
Depending on the size of the config, this could take a while.
### Destroy infrastructure
If something went wrong, or you just want to destroy all infrastructure generated by `deploy`, you can use this command to destroy it.
infra destroy
```
infra destroy
```
Depending on the deployed infrastructure, this could take a while.


### List running instances
This command will list all instances along with their name, type, id and IP.
This is great for debugging.
```bash
infra getIps
```

## Config
This is an example of a working config files
```yaml
peer:
    - name: test peers 1
      amount: 2
      groups:
          - name: message group
            tests:
                - type: text
                  size: 40KB
                  interval: 10
      connections:
          - name: connection
            to: internet
            protocol: tcp
      routers:
          - type: rdvp
            address: test rdvp
          - type: relay
            address: test relay

rdvp:
    - name: test rdvp
      amount: 1
      connections:
          - name: connection
            to: internet
            protocol: tcp

relay:
    - name: test relay
      amount: 1
      connections:
          - name: connection
            to: internet
            protocol: tcp

bootstrap:
    - name: test bs
      amount: 1
      connections:
          - name: connection
            to: internet
            protocol: tcp
      routers:
          - type: relay
            address: test relay
```
There are 5 categories of instances:
- peer
- rdvp
- instance
- bootstrap
- replication server (not yet implemented)

They can be placed in any order, the tool wil automatically calculate the dependencies and instantiate them in the right order.

Some quick terminology to forego any confusion about the naming. This also applies within the codebase:
- the raw AWS instance is referred to as an **Instance**.
- a group of the same type of instances with the same config if referred to as a **NodeGroup**.
- the individual *nodes* inside a NodeGroup are referred to as **Nodes**.
- only when we connect to the nodes (or talk about them in a p2p context), we refer to them as **Peers**.

### Name
Each nodeGroup needs a name. This can be anything, but it's best to keep it descriptive of what it represents.
The name will be propagated down to the individual nodes, but they will have a unique random suffix.

### Amount
This is an integer bigger than 0 defining how many nodes should be in the nodeGroup.
Each node inside the same nodegroup will have identical behaviour. The only difference is the name, IP, tags, etc.
For example if you add a group to a nodeGroup, all nodes inside the nodeGroup will be part of this group.
Same with a router, if you add a RDVP to a nodeGroup, all nodes inside the nodeGroup will be connected to the same RDVP.

### Groups
This can only be used on **peer**s and **replication server**s.
#### Name
Each group has a name. This can be anything.
#### Tests
##### type
This has to be either **text** or **media**
##### size
This defines the size of the message. Example: 10KB, 200KB, 40MB, 4GB.
Although not recommended, it is possible to send large text/image messages.
##### interval
This is the interval between each sent message per node in seconds. Example: 15 -> will wait 15 seconds after sending a message before sending another one.
### Connections
As of right now this is pretty limited with only support for connections to `internet` over `tcp`.
Like this:
```yaml
connections:
  - name: connection
    to: internet
    protocol: tcp
```

### Routers
This can only be used on **peer**s, **replication server**s and **bootstrap**s.
#### type
There exist 3 types of routers: **rdvp**, **relay** and **bootstrap**.
The type has to be either one of these to work.
#### address
The address of a router can be either the name of the router nodeGroup (defined in the config) or an IPFS compliant multi address.
This has support for multiple multi addresses at once separated by comma. If the named router nodeGroup has more than one node, it will automatically add all the nodes' multi address in that field.

